  /*
  muistipeli alusta.
  pit채채 saada toimimaan meid채n piirill채 win ja lose sequenssit toimii, mutta 
  ei ota inputteja
  */




const int NLEDS = 4; 
const int LEDPINS[NLEDS] = {7,8,9,10};
const int SWITCHPINS[NLEDS] = {3,4,5,6};
const int PAUSEB4SEQ = 1000; // Millis before starting the sequence.
const int MINLEVEL = 4;
byte buttonState[4] = {0, 0, 0, 0}; // button state holder
byte lastButtonState[4] = {0, 0, 0, 0}; // store old button state for compare4
byte count = 0; // cycle through button pins
unsigned long lastDebounceTime[4]; // record last time button was pressed
unsigned long time; // record initial time for pattern blinks
/**************************************************************************************************/
int gameLevel;
int simonSez[4]; // sequence saved in this array

/*****************************************************************************************************/
void setup() {	 //rng creates sequence
  randomSeed(analogRead(0));
  gameLevel = 4;
  for (byte l=0; l<NLEDS; l++) {
    pinMode(LEDPINS[l], OUTPUT);
	pinMode(SWITCHPINS[l], INPUT);
  }
  
  playLoseSequence();
  playWinSequence(); 
}
/****************************************************************************************************/
void loop() {
  int done;
  initSequence(gameLevel);
  done = 0;
  while (!done) {
    delay(PAUSEB4SEQ);
    playSequence(gameLevel);

    if (playerGuess(gameLevel)) {
      playWinSequence();
      done = 1;
      }
    
    else {
      playLoseSequence();
    }
  }
}
/***************************************************************************************************************/
void initSequence(int gameLevel) {
  for (int i=0; i<gameLevel; i++) {
    simonSez[i] = random(NLEDS);
  }
}
/*******************************************************************************************************************/
void playSequence(int gameLevel) {
  for (int i=0; i<gameLevel; i++) {
    setLed(simonSez[i]); // Flash the LED in the sequence
    delay(500);
    setLed(-1); // turn all LEDs off
    delay(500);
  }
}
/*******************************************************************************************************************/
void setLed(int theLed) {
  // if not 0<=theLed<NLEDS (e.g. -1), turn all off
  for (int l=0; l<NLEDS; l++) {
    digitalWrite(LEDPINS[l],l==theLed);
  }
}
/**********************************************************************************************************/
int playerGuess(int gameLevel) {
  for (int i=0 ; i<gameLevel ; i++) {
    int guess=getSwitchStroke();
    // player feedback
    digitalWrite(LEDPINS[guess],HIGH);
    delay(250);
    digitalWrite(LEDPINS[guess],LOW);
    if (guess!=simonSez[i]) {
      return 0;
    }
  }
  return 1;
}
/**********************************************************************************************************************/
int playWinSequence() { // Flashes the LEDs victoriously
  for (int i=0; i<4*NLEDS; i++) {
    setLed(i%NLEDS); 
    delay(50);
  }
  setLed(-1); // turn all LEDs off
}
/**************************************************************************************************************/
int playLoseSequence() {// Flashes the LEDs defeatedly
  for (int i=0; i<16; i++) {
    for (int l=0; l<NLEDS; l++) {
      digitalWrite(LEDPINS[l],i&1);
    }
    delay(50);
  }
  setLed(-1); // turn all LEDs off
}
int getSwitchStroke(){   
 
  static unsigned long timeOut = 2000, countDown;
  countDown = millis();

  while (millis() - countDown <= timeOut)

  for (count = 0; count < NLEDS; count++) // loop through all the buttons
    {
      buttonState[count] = digitalRead(SWITCHPINS[count]); // read button states

      if (buttonState[count] != lastButtonState[count]) // check to see if the state has changed from last press
      {
        if (buttonState[count] == LOW)
        {
          lastDebounceTime[count] = millis();// record the time of the last press
          lastButtonState[count] = buttonState[count]; // update old button state for next checking
        }
      }
      if ((millis() - lastDebounceTime[count]) > 50UL)
      {
        if (buttonState[count] == LOW)
        {
          return SWITCHPINS[count];
        }
      }
    }
  }
